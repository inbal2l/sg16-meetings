# SG16 Meeting Summaries

SG16 meetings are typically held on Wednesdays from 3:30pm-5:00pm EST5EDT4 on the 2nd
and 4th weeks of each month, but scheduling conflicts or other time pressures sometimes
force alternative scheduling.  Meeting invitations are sent to the mailing list and
prior attendees.

The next SG16 meeting is scheduled for Wednesday, February 5th 2020, from 3:30-5:00pm EST.

- [January 22nd, 2020](#january-22nd-2020)
- [January 8th, 2020](#january-8th-2020)
- [December 11th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#december-11th-2019)
- [November 20th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#november-20th-2019)
- [October 23rd, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#october-23rd-2019)
- [October 9th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#october-9th-2019)
- [September 25th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#september-25th-2019)
- [September 4th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#september-4th-2019)
- [August 21st, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#august-21st-2019)
- [July 31st, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#july-31st-2019)
- [June 26th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#june-26th-2019)
- [June 12th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#june-12th-2019)
- [May 22nd, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#may-22nd-2019)
- [May 15th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#may-15th-2019)
- [April 24th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#april-24th-2019)
- [April 10th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#april-10th-2019)
- [March 27th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#march-27th-2019)
- [March 13th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#march-13th-2019)
- [February 13th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#february-13th-2019)
- [January 23rd, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#january-23rd-2019)
- [January 9th, 2019](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#january-9th-2019)
- [December 19th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#december-19th-2018)
- [December 5th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#december-5th-2018)
- [October 17th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#october-17th-2018)
- [October 3rd, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#october-3rd-2018)
- [August 29th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#august-29th-2018)
- [July 25th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#july-25th-2018)
- [July 11th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#july-11th-2018)
- [June 20th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#june-20th-2018)
- [May 30th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#may-30th-2018)
- [May 16th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#may-16th-2018)
- [April 25th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#april-25th-2018)
- [April 11th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#april-11th-2018)
- [March 28th, 2018](https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#march-28th-2018)
- [Prior std-text-wg meetings](#prior-std-text-wg-meetings)


# January 22nd, 2020

## Draft agenda:
- P1885R0: Naming Text Encodings to Demystify Them
  - https://wg21.link/p1885
  - Follow up on recent mailing list discussions.
  - Identify and discuss intended use cases.
- P2020R0: Locales, Encodings and Unicode
  - https://isocpp.org/files/papers/P2020R0.pdf
  - General discussion, corrections, suggestions, etc...

## Meeting summary:
- Attendees:
  - Corentin Jabot
  - David Wendt
  - Hubert Tong
  - Jens Maurer
  - Peter Bindels
  - Steve Downey
  - Tom Honermann
  - Zach Laine
- P1885R1: Naming Text Encodings to Demystify Them
  - https://wg21.link/p1885r1
  - Tom introduced the topic for discussion:
    - SG16 approved P1885R0 to forward to LEWG in Belfast.
      - http://wiki.edg.com/bin/view/Wg21belfast/SG16P1885R0
    - Corentin has now provided an R1 with minor updates.
    - Since then, concerns were raised on the SG16 mailing list:
      - https://lists.isocpp.org/sg16/2019/12/0993.php
      - (See email thread continuation in January as well)
    - Questions of use cases have been raised.
  - Corentin stated that use cases haven't changed from his perspective and that the discussion on the
    mailing list went off on a tangent.
  - Tom replied that the discussion suggested a lack of consensus on the importance of a name vs a MIB ID.
  - Corentin stated that what is proposed is just a name intended to resolve issues with names not being
    portable across platforms.  The proposal relies on MIB IDs to correlate names for use with third party
    products.  The proposal does not allow dynamically adding names so as to avoid the possibility of
    inconsistent results.
  - Tom asked what the motivation was for not including enumerators for all MIB IDs in `text_encoding::id`,
    but to require the implementation to support all names and aliases from the
    [IANA Character Set Registry](https://lists.isocpp.org/sg16/2019/12/0993.php).
  - Corentin replied that the requirements were changed in R1.  Hosted implementations are now required to
    support all of the names, but freestanding implementations need not.
  - Tom asked for clarification regarding omission of enumerator IDs.
  - Corentin replied that, if we specify enumerator names for all registered character sets, then we'll
    have to maintain that list.  Additionally, if implementors can add names, that could lead to portability
    or compatibility issues.  Discussion with others prior to Belfast suggested more names were not needed.
  - Jens summarized the concern; the RFC has ~150 names and we would have to put all 150 names into the
    enumeration and deal with the maintenance.  If we select just a few names, then we don't have a
    maintenance burden.
  - Tom countered that use of the `cs` prefixed identifiers described in section 2.3 of
    [RFC 2978](https://tools.ietf.org/html/rfc2978) and maintained in the
    [IANA Character Set Registry](https://lists.isocpp.org/sg16/2019/12/0993.php)
    would avoid the portability and compatibility concerns and provide a specification we can defer to.
  - Corentin replied that it isn't quite that simple because of version skew and that exposing MIB IDs to
    programmers has limited value to begin with.
  - Tom countered that, in the example use case provided in Belfast, you don't necessarily know what the
    name is.
  - \[Editor's note: That example use case is:
    ```
    template<class traits, class Rep, class Period>
    void print_fancy_suffix(basic_ostream<char, traits>& os, const duration<Rep, Period>& d)
    {
      if constexpr (text_encoding::literal().mib == UTF-8) {
        os << d.count() << "\u00B5s";
      } else {
        os << d.count() << "us";
      }
    }
    ```
    \]
  - Corentin replied that the use case could still be covered by comparing the implementation provided
    `text_encoding` object with one constructed by the programmer with a name.
  - \[Editor's note: Presumably something like:
    ```
    template<class traits, class Rep, class Period>
    void print_fancy_suffix(basic_ostream<char, traits>& os, const duration<Rep, Period>& d)
    {
      if constexpr (text_encoding::literal() == text_encoding("UTF-8")) {
        os << d.count() << "\u00B5s";
      } else {
        os << d.count() << "us";
      }
    }
    ```
    \]
  - Tom opined that string names are good for interaction with current third party libraries, but IDs are
    preferred for the example provided
  - Corentin replied that adding more enumerators is ok, but expressed discomfort with deferring to the
    IANA registry due to the possibility of incompatibilities arising from version skew.
  - Steve noted that the proposal only intends to provide portable names; there is no requirement for
    encoders and decoders to be provided.
  - Zach observed that no enumerator is provided for Windows-1252 and asked how an implementor that
    frequently traffics in that encoding would provide support.
  - Corentin responded that a `text_encoding` object can be constructed by name or that the fixed numeric
    value from the IANA registry can be used.
  - JeanHeyd asked if we could reserve a range of MIB IDs for use by implementations similar to the Private
    Use Area in Unicode.
  - Corentin replied that he is strongly opposed to doing so.
  - Corentin asked if we really want all of these names to be available as identifiers when we can just
    use strings.
  - Zach responded that he thinks it makes sense for cases where we know compilers default to certain encodings.
  - Corentin repeated that he doesn't want implementors to add their own names.
  - Jens asked about the source for the names whether as strings or identifiers.
    [RFC 3808](https://tools.ietf.org/html/rfc3808) lists the MIB names with interesting spellings, and
    [RFC 2978](https://tools.ietf.org/html/rfc2978) defines a registration process, but neither provides
    the latest names.
  - Steve provided the URL to the IANA registry and explained that the RFCs don't change, but specify the
    URL for the registry; which doesn't change often.
    - https://www.iana.org/assignments/character-sets/character-sets.xhtml
  - Tom added that the IANA registry mostly changes for administrative reasons, not because of new character
    set registrations.
  - Jens asked how it is determined which names are good for enumerators.
  - Tom replied that
    [RFC 2978](https://tools.ietf.org/html/rfc2978) specifies that each registered character set have an
    associated name prefixed with "cs" that is appropriate for use as an identifier.
  - Jens asked why the names in the proposal do not match the "cs" names.
  - Corentin responded that he picked names that he preferred.
  - Jens asserted that, in that case, implementors cannot extend the list.
  - Zach stated that there isn't much cost in taking the list of "cs" prefixed names, removing dashes, and
    dumping that list in the wording and asked again for motivation for omitting them.
  - Corentin replied that he thought they were not needed.
  - Zach agreed that many would not be used much, but determining which ones are important would be difficult
    where as just including them all would be easy.
  - Tom asked Corentin, why he felt comfortable deferring to the IANA registry for string names, but not for
    enumerator names?
  - Corentin replied that he felt that the names and alias names were definitive, but that the enumerator
    names seemed more fuzzy.
  - Corentin asked Jens if there are concerns regarding the use of trademark names in the standard; many of
    the character set names include trademark names.
  - Jens replied that we already use trademarked names like Windows and POSIX in the filesystem specification.
  - Steve added that these names have already been vetted by their respective owners, if necessary, for
    inclusion in the registry.
  - Jens asked if the names in the IANA registry might already be reflected in an ISO standard that we could
    reference instead.
  - Corentin replied that he was unaware of such an ISO standard.
  - Tom asked Jens how a search for such an ISO standard could be conducted.
  - Jens suggested searching for "character set" in the ISO list.
  - Steve noted that the RFC describing the IANA registration process does mention ISO standards such as
    ISO 10646, ISO 8859, and ISO 2022.
  - Corentin stated that web browsers, iconv, ICU, etc... all use the IANA registry; it is the defacto standard.
  - Jens expressed some uncertainty with regard to how to refer to these RFCs from the standard, but mentioned
    that we did similarly for the time zone database which is even less regulated.
  - Jens raised a concern about impact to small/embedded implementations.  As proposed, they would have to
    include an instance of the string name table with every instance of the program and that could be problematic
    even for some hosted implementations.
  - Tom suggested that, if the string table is not referenced; e.g., if none of the `text_encoding` factory
    functions is referenced or if the `<text_encoding>` header is not included, that the implementation might
    be able to omit it.
  - Jens suggested that it would be helpful if the paper addressed cost of implementation and anticipated
    impact to deployments.
  - JeanHeyd suggested that the guarantee we make should be that if only `text_encoding::system()` or
    `text_encoding::literal()` are called, then there should be no string table overhead.
  - Jens asked if an implementation could provide support for a reduced set of names.  If not, the discussion of
    how to reduce deployment cost is warranted since, as proposed, this is not a zero-cost of zero-overhead
    solution.
  - Jens also stated a preference for the `system()` and `wide_system()` functions to return a MIB ID rather
    than a `text_encoding` object.
  - Corentin responded that there may be cases where the system encoding is not registered with IANA.  In that
    case, the MIB ID would be "unknown"; and a different interface would have to be used to retrieve the string
    name of the encoding anyway.
  - JeanHeyd provided WTF-8 and Modified UTF-8 as examples of encodings that are not registered with IANA but
    that are known to be in use on Android and elsewhere on the web.
  - Jens suggested that, in such cases, the implementation register their encoding.
  - Zach asked to clarify what the motivation is for supporting string names at all.
  - Tom responded that third party products like iconv and ICU have interfaces that require use of string names.
  - Corentin confirmed.
  - Tom added that the IANA registry is effectively a common subset of recognized names.
  - Zach stated a preference for omitting string names and just relying on MIB IDs.
  - Corentin responded that doing so would complicate use of iconv.
  - Hubert expressed a lack of motivation for an interface that relies on numeric values that no one knows;
    the string names make sense.
  - Jens pondered if string name to MIB ID lookup was an orthogonal feature.
  - Tom stated that question was posed in the mailing list discussion as well.
  - Corentin mentioned existing host system interfaces.  Windows provides a code page with an ID.  POSIX systems
    provide a name and no ID.
  - Jens suggested that an interface that provides a string name does not suit all use cases.  For example,
    a programmer might desire to assert a specific system encoding; that shouldn't require a full string table.
  - Zach expressed a desire for the interface to provide more safety and that he would prefer a list of
    identifiers over a list of string names.
  - Hubert suggested other benefits of the string names, 1) useful for interaction with the system and third party
    libraries, and 2) useful for interchange or serialization.
  - Hubert expressed concern about use of a string interface for looking up an encoding name and asked what name
    is provided in response to a lookup of a MIB ID.
  - Corentin replied that there is no proposed lookup interface that accepts a MIB ID.  The factory interfaces
    like `text_encoding::system()` return a preferred name, but otherwise, the name provided when constructing
    a `text_encoding` object is preserved.
  - Jens expressed a desire for a low-level interface that just returns an integer that could be used to assert
    the environment is UTF-8 without having to compare with a bunch of strings; that could be a zero overhead
    facility.
  - Hubert asked if there is overhead if neither of `text_encoding::system()` or `text_encoding::wide_system()`
    is called.
  - Corentin responded that yes, there is, but it is low.
  - Hubert cautioned that some standard library implementors are likely to oppose anything that increases
    startup cost or requires "static constructors".
  - Tom asked why the interface couldn't perform a lazy lookup.
  - Corentin responded that calls to `setlocale()` could interfere; `text_encoding::system()` is intended to
    return the locale dependent encoding known at program startup time.
  - \[Editor's note: Later discussion on the SG16 mailing list revealed that it is possible on POSIX systems
    to retrieve the locale dependent encoding known at program startup time regardless of intervening calls
    to `setlocale()` with code like:
    ```
     locale_t loc = newlocale(LC_CTYPE_MASK, "", (locale_t)0);
     const char* name = nl_langinfo_l(CODESET, loc);
     ...
     freelocale(loc); 
    ```
    \]
  - Hubert suggested that programmers can collect this information on their own and that they should be aware if
    some library is calling `setlocale()` before `main()` is invoked.
  - Tom agreed, but stated that doing so is hard in practice, particularly for library authors.
  - JeanHeyd observed that the C library behavior depends on the currently set locale and asked what benefit
    is provided by `test_encoding::system()` if it's not in sync with the C and C++ libraries.
  - Tom responded that it indicates what encoding is expected for I/O outside of the process.
- Tom confirmed that the next meeting will be on February 5th and that it will be the last meeting before we
  meet in Prague.


# January 8th, 2020

## Draft agenda:
- LWG issue 3341: basic_regex range constructor: Missing requirements for iterator types
  - https://cplusplus.github.io/LWG/issue3341
  - Billy O'Neal copied SG16 on this issue; see https://lists.isocpp.org/sg16/2019/12/0990.php
  - What should be the proposed resolution?
- P1949: C++ Identifier Syntax using Unicode Standard Annex 31:
  - https://wg21.link/p1949
  - Which UAX #31 requirements do we intend to satisfy (see section 2)?
  - Which UAX #31 specific character adjustments do we want (see section 2.4)?
  - Which UAX #31 NFKC modifications we we want (see section 5.1)?

## Meeting summary:
- Attendees:
  - David Wendt
  - JeanHeyd Meneide
  - Lyberta
  - Peter Bindels
  - Steve Downey
  - Tom Honermann
  - Zach Laine
- LWG issue 3341: basic_regex range constructor: Missing requirements for iterator types
  - https://cplusplus.github.io/LWG/issue3341
  - Tom introduced the topic:
    - Billy O'Neal copied SG16 on this issue.  His email is available in the SG16 mailing list archives
      at https://lists.isocpp.org/sg16/2019/12/0990.php.
    - What should be the proposed resolution?
  - Zach asked why we should be concerned about this issue.
  - Tom responded that Billy copied us on it, presumably seeking our input.
  - Zach stated that implicit transcoding should not occur; The safest thing to do would be to require
    `ForwardIterator::value_type` to be exactly `charT`.
  - JeanHeyd agreed with the no implicit transcoding stance; that would make `std:regex` even slower!
  - Peter chimed in via chat agreeing with an exact type requirement and the following constraint:
    - `std::is_same_t<value_type, decltype(*std::declval<ForwardIterator>()>`
  - Peter asked if we should enable views to be used as inputs.
  - Steve stated that would be a more difficult challenge given the recent difficulties faced when
    attempting to add range constructors for standard containers.
  - Zach agreed that adding range support could be difficult and is out of scope for this issue anyway.
  - Peter concurred and noted that view support can always be added later.
  - Tom observed that if a same type constraint is added, then SFINAE will kick in, but it might be
    preferred to make it a hard error if the iterator value type doesn't match.
  - Zach suggested leaving that for LWG to decide.
  - Tom agreed and stated he would respond to Billy's email and LWG with our thoughts.
- P1949: C++ Identifier Syntax using Unicode Standard Annex 31:
  - https://wg21.link/p1949
  - https://github.com/cplusplus/nbballot/issues/28
  - Tom introduced the topic.
    - In Belfast, EWG did not accept
      [SG16's recommended resolution for NL029](http://wiki.edg.com/bin/view/Wg21belfast/SG16NBNL029)
      for C++20.
    - Tom volunteered to submit a core issue for C++20 in order to allow us to resolve the concern as
      a defect, but he doesn't have a PR to propose.
    - Tom is thinking about bailing on submitting that core issue, but thought he would check if SG16
      might have consensus on what solution we would want.  In particular, if we were to adopt
      [UAX #31](https://www.unicode.org/reports/tr31/tr31-31.html), what would be our answers to these
      questions?
      - Which UAX #31 requirements do we intend to satisfy (see section 2)?
      - Which UAX #31 specific character adjustments do we want (see section 2.4)?
      - Which UAX #31 NFKC modifications we we want (see section 5.1)?
  - Zach suggested we skip C++20 and just proceed with addressing this for C++23.
  - Steve provided motivation for dealing with this as a DR; some compilers are just starting to allow
    extended characters in identifiers.  Previously, programmers had to go out of their way to create
    weird identifiers.  Clang has allowed extended characters forever (since Clang 3.3 or so), gcc
    support was added for gcc 10.  The window for changing behavior is shrinking.
  - Zach asked if the concern was about breaking existing code given that this isn't the kind of break
    we usually worry too much about.
  - Tom replied that the breakage could be silent if Unicode normalization affects whether two
    identifiers match.
  - Steve added that breakage could occur due to excluded characters like the poop emoji.  Compilers
    could provide backward compatibility options; Hyrum's law.
  - Steve continued stating that, if we don't get this nailed down for C++23, we could probably still
    do it because it probably won't affect that much code.
  - Zach observed that the impact would mostly be due to banning emoji.
  - Steve agreed; emoji is the only case people are likely to notice.  Programmers aren't likely to
    want right-to-left characters in identifiers for example.
  - Which UAX #31 requirements do we intend to satisfy (see section 2)?
    - Tom stated that we need to choose whether to use the `ID_Start`/`ID_Continue` or
      `XID_Start`/`XID_Continue` properties to define identifier syntax.  P1949 suggests using the
      `XID_Start`/`XID_Continue` variants and doing so is necessary to meet the requirements for
      [UAX31-R1](https://www.unicode.org/reports/tr31/tr31-31.html#R1) without defining a profile;
      though, we'll need a profile to add `_` as a start character.
    - Steve recommended we adopt the XID variants and add `_` as a start character.  However, this
      doesn't suffice to guarantee identifier stability.
    - Tom stated that, in order to meet requirement
      [UAX31-R1a](https://www.unicode.org/reports/tr31/tr31-31.html#R1a), that he thinks we'll need
      to specify additional characters to exclude.  The NL029 NB comment specified a particular range
      to exclude, but he is not sure if or how that matches UAX31.
    - Steve corrected Tom's interpretation; that requirement allows opting in to characters that are
      disallowed by default.
    - Peter stated that section 2.3 explains that some character that are restricted by default are
      needed in some cases for some scripts.
    - Peter continued stating that he thinks we lack the experience to make choices in this regard and
      suggested we proceed with more restrictions now and relax them later based on experience and
      motivation.
    - Tom asked about meeting the requirements for
      [UAX31-R1b](https://www.unicode.org/reports/tr31/tr31-31.html#R1b); assuming we want to meet
      that requirement, how would we do so?
    - Steve responded that, given ABI issues, we should commit to meeting this requirement.  In
      practice, that means that, for example, if a future Unicode standard were to remove characters
      from `XID_CONTINUE`, that we would update our profile to add them back in.
    - Peter asked if the `XID_Start`/`XID_Continue` properties are stable.
    - Zach responded that he understood them to be stable.
    - Steve responded that they are derived properties and are not guaranteed to be stable, but
      probably will be in practice.  \[Editor's note: in later email discussion, Steve offered a
      correction to this statement: `XID_Start` and `XID_Continue` are guaranteed stable, just not
      immutable. Immutability is the property that things that are not identifiers remain not
      identifiers. \]
    - Zach mentioned that he wasn't previously aware that UAX31 had options, but it seems our goal
      now needs to be to identify the options, select them, and then make sure proposed wording
      reflects our intent.
    - Tom agreed.
  - Which UAX #31 specific character adjustments do we want (see section 2.4)?
    - Peter, reviewing section 2.4, stated no observed need for exceptions other than for `_` in
      the start position; a choice that is already explicitly listed as an option.
  - Which UAX #31 NFKC modifications we we want (see section 5.1)?
    - Tom stated that we need to figure out how to deal with normalization if we want stable
      identifiers.
    - Zach provided some background on NFC, NFD, compatibility, comparisons, and conversions.
    - Zach professed support for standardizing on NFC; NFD is not really usable since combining
      marks don't tend to be represented by themselves in identifiers.
    - Tom asked if standardizing on NFC commits implementors to perform normalization.
    - Steve responded that gcc 10 already emits a warning for identifiers that are written in
      non-NFC forms in source code.
    - Zach stated that checking for NFC is fast, at least for common cases, so diagnosing is
      reasonable, but stating that non-NFC identifiers are IFNDR (ill-formed no diagnostic required)
      is also a possibility.
    - Tom observed that conversions from other character sets like Windows-1252 probably always
      result in NFC.
    - Zach agreed noting that such conversion is probably done via the compiler's internal encoding.
    - Peter stated that there are other character sets that have combining marks, but none of those
      are probably supported by compilers.
    - Tom, considering source code that is encoded as UTF-8 in NFD, asked if requiring NFC could be
      problematic for existing editors and tools.
    - Steve observed that this issue already exists and that tools today already expect NFC.
    - Peter recommended that we make use of non-NFC normalized source code IFNDR and encourage tools
      to diagnose violations.
    - Zach responded that IFNDR is generally reserved for cases where something can't be reasonably
      diagnosed; since diagnosis is reasonable here, non-NFC forms should be considered ill-formed.
    - Steve added that compiler implementors can support options to relax NFC checking.
    - Tom noted that this creates a specification issue since, if source encoding is not UTF-8, it
      needs to be transcoded to NFC, but if it is UTF-8, source code needs to already be in NFC.
    - Zach responded that we don't have to; we just specify the characters that are valid based on
      `XID_Start`/`XID_Continue`.
    - Steve added that the NFC check has to be done after conversion from source encoding to internal
      encoding and that he is unaware of any encoding that does not naturally transcode to NFC.
    - Peter observed that combining diacritics are part of `XID_Continue` and that there are
      therefore two spellings of café; a 4 code point variant using
      U+00E9 {LATIN SMALL LETTER E WITH ACUTE} and a 5 code point variant using
      U+0301 {COMBINING ACUTE ACCENT}.
    - Zach stated that this feature requires the compiler's internal encoding to be Unicode.
    - Tom responded that, since C++11, the internal encoding must already be isomorphic to Unicode.
    - Zach suggested that both forms of café should not be allowed; that NFC should be required, and
      that use of combining characters should be disallowed in our profile.
    - Steve responded that disallowing all combining characters probably isn't feasible; there aren't
      precomposed forms of all characters; in NFC, combining characters will still appear, but only
      when they are actually required.
    - Zach suggested this is a restriction that could be relaxed later.
    - Steve observed that this would make specification of the profile more difficult.
    - Zach agreed and suggested just specifying a list of start and continue characters; this avoids
      implementors having to do hard things.
    - Peter noticed a problem with that approach; new Unicode characters could not be used unless and
      until the standard is updated with a new list of start/continue characters.
    - Tom added that this is why we want to defer to the implementation-defined Unicode version.
    - Steve added this is also why we want the identifier stability guarantee; otherwise we get
      linkage problems.
    - Peter suggested it should be ok to define a profile with `<Start>` defined as `XID_Start` + '_',
      and `<Continue>` defined as `XID_Continue` - <all_combining_characters>.
    - Steve noted that we have a floating Unicode reference today.
    - Tom agreed but noted that we have not yet required implementors to state which version of Unicode
      they conform to.
    - Steve agreed and added that, technically, we only have a floating reference to ISO/IEC 10646; this
      may not cover the normalization algorithm.
    - Steve summarized some options; there are two ways to deal with NFC: 1) source must be NFC normalized,
      and 2) the compiler internal encoding must be NFC.  Not allowing combining characters gives us the
      stability that we need without having to distinguish between those options.
    - Steve continued that omitting combining characters avoids the problem of Unicode introducing new
      precomposed characters that previously had to be represented with a combining character thereby
      changing NFC.
    - Tom responded that he thought the Unicode standard has a stability guarantee that new precomposed
      characters will not be introduced.
    - Peter observed that allowing combining characters is therefore required for new characters.
    - Tom suggested we need to do some more research.
    - Steve, after checking the Unicode standard, reported that normalization forms are guaranteed to be
      stable.
    - Zach quoted from section 3 of [UAX #15](https://www.unicode.org/reports/tr15/tr15-48.html):
      - "It is crucial that Normalization Forms remain stable over time. That is, if a string that does
        not have any unassigned characters is normalized under one version of Unicode, it must remain
        normalized under all future versions of Unicode."
    - Peter repeated his guidance that combining characters must be allowed in order to support some
      scripts.
    - Tom agreed and acknowledged that we probably therefore need to require NFC.
    - Tom summarized options identified so far:
      - 1) The compiler converts to NFC internally.  This could technically break some existing code.
      - 2) Require UTF encoded source files to be NFC and that non-UTF encoded source files be transcoded
           (noting that we believe that transcoding from any existing character sets will produce NFC).
    - Zach observed that the implementation effort is equivalent for those cases since an NFC check can
      bail out early if the check fails, but is otherwise same amount of work so that the complexity cost
      is the same.
    - Steve stated that he may not be in Prague, but that others can champion the paper as needed.
    - Peter and Zach both volunteered to champion.
    - Steve stated he would try to get an updated revision submitted for the Prague pre-meeting mailing.
- Tom stated that the next meeting will be January 22nd.


# December 11th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#december-11th-2019.


# November 20th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#november-20th-2019.


# October 23rd, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#october-23rd-2019.


# October 9th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#october-9th-2019.


# September 25th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#september-25th-2019.


# September 4th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#september-4th-2019.


# August 21st, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#august-21st-2019.


# July 31st, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#july-31st-2019.


# June 26th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#june-26th-2019.


# June 12th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#june-12th-2019.


# May 22nd, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#may-22nd-2019.


# May 15th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#may-15th-2019.


# April 24th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#april-24th-2019.


# April 10th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#april-10th-2019.


# March 27th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#march-27th-2019.


# March 13th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#march-13th-2019.


# February 13th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#february-13th-2019.


# January 23rd, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#january-23rd-2019.


# January 9th, 2019

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#january-9th-2019.


# December 19th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#december-19th-2018.


# December 5th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#december-5th-2018.


# October 17th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#october-17th-2018.


# October 3rd, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#october-3rd-2018.


# August 29th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#august-29th-2018.


# July 25th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#july-25th-2018.


# July 11th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#july-11th-2018.


# June 20th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#june-20th-2018.


# May 30th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#may-30th-2018.


# May 16th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#may-16th-2018.


# April 25th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#april-25th-2018.


# April 11th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#april-11th-2018.


# March 28th, 2018

See https://github.com/sg16-unicode/sg16-meetings/blob/master/README-2018.md#march-28th-2018.


# Prior std-text-wg meetings

Meetings held by the informal std-text-wg working group prior to the
formation of SG16 are available at:
- https://github.com/tahonermann/std-text-wg/blob/master/MeetingNotes.md
